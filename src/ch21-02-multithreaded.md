<!-- Old headings. Do not remove or links may break. -->

<a id="turning-our-single-threaded-server-into-a-multithreaded-server"></a>
<a id="from-single-threaded-to-multithreaded-server"></a>

## من خادم أحادي المسار إلى خادم متعدد المسارات (Multithreaded)

في الوقت الحالي، يقوم الخادم بمعالجة كل طلب بالترتيب، مما يعني أنه لن يعالج اتصالاً ثانياً حتى ينتهي من معالجة الاتصال الأول. إذا تلقى الخادم المزيد والمزيد من الطلبات، فسيكون هذا التنفيذ التسلسلي أقل كفاءة بشكل متزايد. إذا تلقى الخادم طلباً يستغرق وقتاً طويلاً للمعالجة، فستضطر الطلبات اللاحقة إلى الانتظار حتى ينتهي الطلب الطويل، حتى لو كان من الممكن معالجة الطلبات الجديدة بسرعة. سنحتاج إلى إصلاح ذلك، ولكن أولاً سنلقي نظرة على المشكلة بشكل عملي.

<!-- Old headings. Do not remove or links may break. -->

<a id="simulating-a-slow-request-in-the-current-server-implementation"></a>

### محاكاة طلب بطيء

سنلقي نظرة على كيفية تأثير طلب بطيء المعالجة على الطلبات الأخرى المقدمة إلى تنفيذ الخادم الحالي لدينا. تنفذ القائمة 21-10 معالجة طلب إلى المسار _/sleep_ مع استجابة بطيئة محاكاة ستجعل الخادم ينام لمدة خمس ثوانٍ قبل الاستجابة.

<Listing number="21-10" file-name="src/main.rs" caption="محاكاة طلب بطيء عن طريق النوم لمدة خمس ثوانٍ">

```rust,no_run
{{#rustdoc_include ../listings/ch21-web-server/listing-21-10/src/main.rs:here}}
```

</Listing>

لقد انتقلنا من استخدام `if` إلى `match` الآن بعد أن أصبح لدينا ثلاث حالات. نحتاج إلى المطابقة صراحةً على شريحة (slice) من `request_line` لمطابقة النمط مع قيم السلسلة النصية الثابتة؛ حيث لا يقوم `match` بعملية الإسناد المرجعي وإلغاء الإسناد (referencing and dereferencing) تلقائياً كما تفعل دالة المساواة.

الذراع الأول هو نفسه كتلة `if` من القائمة 21-9. الذراع الثاني يطابق طلباً إلى _/sleep_. عند استلام هذا الطلب، سينام الخادم لمدة خمس ثوانٍ قبل عرض صفحة HTML الناجحة. الذراع الثالث هو نفسه كتلة `else` من القائمة 21-9.

يمكنك أن ترى مدى بساطة خادمنا: المكتبات الحقيقية ستتعامل مع التعرف على الطلبات المتعددة بطريقة أقل إسهاباً بكثير!

ابدأ تشغيل الخادم باستخدام `cargo run`. ثم افتح نافذتين في المتصفح: واحدة لـ _http://127.0.0.1:7878_ والأخرى لـ _http://127.0.0.1:7878/sleep_. إذا قمت بإدخال عنوان _/_ عدة مرات، كما فعلت سابقاً، فسترى أنه يستجيب بسرعة. ولكن إذا أدخلت _/sleep_ ثم قمت بتحميل _/_، فسترى أن _/_ ينتظر حتى ينتهي `sleep` من نومه لمدة خمس ثوانٍ كاملة قبل التحميل.

هناك تقنيات متعددة يمكننا استخدامها لتجنب تراكم الطلبات خلف طلب بطيء، بما في ذلك استخدام البرمجة غير المتزامنة (async) كما فعلنا في الفصل 17؛ والتقنية التي سنقوم بتنفيذها هي "حوض المسارات" (thread pool).

### تحسين معدل النقل باستخدام حوض المسارات (Thread Pool)

"حوض المسارات" (thread pool) هو مجموعة من المسارات (threads) التي تم إنشاؤها وهي جاهزة وتنتظر معالجة مهمة ما. عندما يتلقى البرنامج مهمة جديدة، فإنه يعين أحد المسارات في الحوض للمهمة، وسيقوم هذا المسار بمعالجة المهمة. تظل المسارات المتبقية في الحوض متاحة للتعامل مع أي مهام أخرى تأتي أثناء معالجة المسار الأول. عندما ينتهي المسار الأول من معالجة مهمته، يتم إعادته إلى حوض المسارات الخاملة، ليكون جاهزاً للتعامل مع مهمة جديدة. يسمح لك حوض المسارات بمعالجة الاتصالات بشكل متزامن (concurrently)، مما يزيد من معدل نقل البيانات (throughput) في خادمك.

سنحدد عدد المسارات في الحوض برقم صغير لحمايتنا من هجمات الحرمان من الخدمة (DoS)؛ فلو جعلنا برنامجنا ينشئ مساراً جديداً لكل طلب يأتي، لتمكن شخص يقوم بتقديم 10 ملايين طلب إلى خادمنا من إحداث فوضى عارمة عن طريق استهلاك جميع موارد خادمنا وإيقاف معالجة الطلبات تماماً.

بدلاً من إنشاء مسارات غير محدودة، سيكون لدينا عدد ثابت من المسارات التي تنتظر في الحوض. يتم إرسال الطلبات الواردة إلى الحوض للمعالجة. سيحتفظ الحوض بطابور (queue) من الطلبات الواردة. سيقوم كل مسار من المسارات في الحوض بسحب طلب من هذا الطابور، ومعالجة الطلب، ثم يطلب من الطابور طلباً آخر. بهذا التصميم، يمكننا معالجة ما يصل إلى _`N`_ من الطلبات بشكل متزامن، حيث _`N`_ هو عدد المسارات. إذا كان كل مسار يستجيب لطلب يستغرق وقتاً طويلاً، فلا يزال بإمكان الطلبات اللاحقة التراكم في الطابور، لكننا زدنا عدد الطلبات طويلة الأمد التي يمكننا التعامل معها قبل الوصول إلى تلك النقطة.

هذه التقنية هي مجرد واحدة من طرق عديدة لتحسين معدل نقل خادم الويب. الخيارات الأخرى التي قد تستكشفها هي نموذج fork/join، ونموذج الإدخال/الإخراج غير المتزامن أحادي المسار، ونموذج الإدخال/الإخراج غير المتزامن متعدد المسارات. إذا كنت مهتماً بهذا الموضوع، يمكنك قراءة المزيد عن الحلول الأخرى ومحاولة تنفيذها؛ فمع لغة منخفضة المستوى مثل Rust، كل هذه الخيارات ممكنة.

قبل أن نبدأ في تنفيذ حوض المسارات، دعونا نتحدث عن الشكل الذي يجب أن يكون عليه استخدام الحوض. عندما تحاول تصميم كود، فإن كتابة واجهة العميل أولاً يمكن أن تساعد في توجيه تصميمك. اكتب الواجهة البرمجية (API) للكود بحيث تكون منظمة بالطريقة التي تريد استدعاءها بها؛ ثم قم بتنفيذ الوظائف داخل هذا الهيكل بدلاً من تنفيذ الوظائف ثم تصميم الواجهة البرمجية العامة.

على غرار كيفية استخدامنا للتطوير المدفوع بالاختبار (TDD) في مشروع الفصل 12، سنستخدم هنا التطوير المدفوع بالمترجم (compiler-driven development). سنكتب الكود الذي يستدعي الدوال التي نريدها، ثم سننظر في الأخطاء الواردة من المترجم لتحديد ما يجب تغييره تالياً لجعل الكود يعمل. قبل القيام بذلك، سنستكشف التقنية التي لن نستخدمها كنقطة انطلاق.

<!-- Old headings. Do not remove or links may break. -->

<a id="code-structure-if-we-could-spawn-a-thread-for-each-request"></a>

#### إنشاء مسار لكل طلب

أولاً، دعونا نستكشف كيف قد يبدو الكود الخاص بنا إذا قام بإنشاء مسار جديد لكل اتصال. كما ذكرنا سابقاً، هذه ليست خطتنا النهائية بسبب مشاكل احتمال إنشاء عدد غير محدود من المسارات، ولكنها نقطة انطلاق للحصول على خادم متعدد المسارات يعمل أولاً. بعد ذلك، سنضيف حوض المسارات كتحسين، وسيكون التباين بين الحلين أسهل.

توضح القائمة 21-11 التغييرات التي يجب إجراؤها على `main` لإنشاء مسار جديد للتعامل مع كل تدفق (stream) داخل حلقة `for`.

<Listing number="21-11" file-name="src/main.rs" caption="إنشاء مسار جديد لكل تدفق">

```rust,no_run
{{#rustdoc_include ../listings/ch21-web-server/listing-21-11/src/main.rs:here}}
```

</Listing>

كما تعلمت في الفصل 16، سيقوم `thread::spawn` بإنشاء مسار جديد ثم تشغيل الكود الموجود في الإغلاق (closure) في المسار الجديد. إذا قمت بتشغيل هذا الكود وتحميل _/sleep_ في متصفحك، ثم _/_ في علامتي تبويب إضافيتين، فسترى بالفعل أن الطلبات إلى _/_ لا تضطر إلى انتظار انتهاء _/sleep_. ومع ذلك، كما ذكرنا، سيؤدي هذا في النهاية إلى إرهاق النظام لأنك ستنشئ مسارات جديدة دون أي حدود.

قد تتذكر أيضاً من الفصل 17 أن هذا هو بالضبط نوع الموقف الذي تتألق فيه البرمجة غير المتزامنة (async) و (await)! ضع ذلك في اعتبارك بينما نبني حوض المسارات وفكر في كيف ستكون الأمور مختلفة أو متشابهة مع async.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-a-similar-interface-for-a-finite-number-of-threads"></a>

#### إنشاء عدد محدود من المسارات

نريد أن يعمل حوض المسارات الخاص بنا بطريقة مماثلة ومألوفة بحيث لا يتطلب الانتقال من المسارات إلى حوض المسارات تغييرات كبيرة في الكود الذي يستخدم واجهتنا البرمجية. توضح القائمة 21-12 الواجهة الافتراضية لهيكل `ThreadPool` الذي نريد استخدامه بدلاً من `thread::spawn`.

<Listing number="21-12" file-name="src/main.rs" caption="واجهة ThreadPool المثالية لدينا">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch21-web-server/listing-21-12/src/main.rs:here}}
```

</Listing>

نستخدم `ThreadPool::new` لإنشاء حوض مسارات جديد بعدد قابل للتكوين من المسارات، في هذه الحالة أربعة. ثم، في حلقة `for` تمتلك `pool.execute` واجهة مماثلة لـ `thread::spawn` من حيث أنها تأخذ إغلاقاً يجب أن يشغله الحوض لكل تدفق. نحتاج إلى تنفيذ `pool.execute` بحيث تأخذ الإغلاق وتعطيه لمسار في الحوض لتشغيله. لن يتم تجميع هذا الكود بعد، لكننا سنحاول حتى يتمكن المترجم من توجيهنا في كيفية إصلاحه.

<!-- Old headings. Do not remove or links may break. -->

<a id="building-the-threadpool-struct-using-compiler-driven-development"></a>

#### بناء ThreadPool باستخدام التطوير المدفوع بالمترجم

قم بإجراء التغييرات في القائمة 21-12 على ملف _src/main.rs_، ثم دعنا نستخدم أخطاء المترجم من `cargo check` لتوجيه تطويرنا. إليك الخطأ الأول الذي نحصل عليه:

```console
{{#include ../listings/ch21-web-server/listing-21-12/output.txt}}
```

رائع! يخبرنا هذا الخطأ أننا بحاجة إلى نوع أو وحدة `ThreadPool` لذا سنقوم ببناء واحدة الآن. سيكون تنفيذ `ThreadPool` الخاص بنا مستقلاً عن نوع العمل الذي يقوم به خادم الويب الخاص بنا. لذا، دعونا نحول صندوق `hello` من صندوق ثنائي إلى صندوق مكتبة (library crate) ليحتوي على تنفيذ `ThreadPool` الخاص بنا. بعد التغيير إلى صندوق مكتبة، يمكننا أيضاً استخدام مكتبة حوض المسارات المنفصلة لأي عمل نريد القيام به باستخدام حوض مسارات، وليس فقط لخدمة طلبات الويب.

أنشئ ملف _src/lib.rs_ يحتوي على ما يلي، وهو أبسط تعريف لهيكل `ThreadPool` يمكننا الحصول عليه في الوقت الحالي:

<Listing file-name="src/lib.rs">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/no-listing-01-define-threadpool-struct/src/lib.rs}}
```

</Listing>


ثم، قم بتحرير ملف _main.rs_ لجلب `ThreadPool` إلى النطاق من صندوق المكتبة عن طريق إضافة الكود التالي إلى أعلى ملف _src/main.rs_:

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch21-web-server/no-listing-01-define-threadpool-struct/src/main.rs:here}}
```

</Listing>

لا يزال هذا الكود لا يعمل، ولكن دعنا نتحقق منه مرة أخرى للحصول على الخطأ التالي الذي نحتاج إلى معالجته:

```console
{{#include ../listings/ch21-web-server/no-listing-01-define-threadpool-struct/output.txt}}
```

يشير هذا الخطأ إلى أننا نحتاج تالياً إلى إنشاء دالة مرتبطة تسمى `new` لـ `ThreadPool`. نعلم أيضاً أن `new` تحتاج إلى معامل واحد يمكنه قبول `4` كمعامل ويجب أن تعيد نسخة من `ThreadPool`. دعونا ننفذ أبسط دالة `new` تمتلك تلك الخصائص:

<Listing file-name="src/lib.rs">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/no-listing-02-impl-threadpool-new/src/lib.rs}}
```

</Listing>

اخترنا `usize` كنوع لمعامل `size` لأننا نعلم أن عدداً سالباً من المسارات لا معنى له. نعلم أيضاً أننا سنستخدم هذا... (تم اختصار المحتوى بسبب حدود الحجم)

...

لنبدأ بإنشاء قناة (channel) في `ThreadPool::new` والاحتفاظ بالمرسل (sender) في نسخة `ThreadPool` كما هو موضح في القائمة 21-16. هيكل `Job` لا يحمل أي شيء في الوقت الحالي ولكنه سيكون نوع العنصر الذي نرسله عبر القناة.

<Listing number="21-16" file-name="src/lib.rs" caption="تعديل ThreadPool لتخزين مرسل القناة التي تنقل نسخ Job">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/listing-21-16/src/lib.rs:here}}
```

</Listing>

في `ThreadPool::new` ننشئ قناتنا الجديدة ونجعل الحوض يحتفظ بالمرسل. سيتم تجميع هذا بنجاح.

دعونا نحاول تمرير مستقبل (receiver) القناة إلى كل `Worker` بينما يقوم حوض المسارات بإنشاء القناة. نعلم أننا نريد استخدام المستقبل في المسار الذي تنشئه نسخ `Worker` لذا سنشير إلى معامل `receiver` في الإغلاق. الكود في القائمة 21-17 لن يتم تجميعه تماماً بعد.

<Listing number="21-17" file-name="src/lib.rs" caption="تمرير المستقبل إلى كل Worker">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch21-web-server/listing-21-17/src/lib.rs:here}}
```

</Listing>

لقد أجرينا بعض التغييرات الصغيرة والمباشرة: نمرر المستقبل إلى `Worker::new` ثم نستخدمه داخل الإغلاق.

عندما نحاول التحقق من هذا الكود، نحصل على هذا الخطأ:

```console
{{#include ../listings/ch21-web-server/listing-21-17/output.txt}}
```

يحاول الكود تمرير `receiver` إلى نسخ `Worker` متعددة. هذا لن يعمل، كما ستتذكر من الفصل 16: تنفيذ القناة الذي توفره Rust هو "منتجون متعددون، مستهلك واحد" (multiple producer, single consumer). هذا يعني أنه لا يمكننا ببساطة استنساخ طرف الاستهلاك في القناة لإصلاح هذا الكود. كما أننا لا نريد إرسال رسالة عدة مرات إلى مستهلكين متعددين؛ نريد قائمة واحدة من الرسائل مع نسخ `Worker` متعددة بحيث تتم معالجة كل رسالة مرة واحدة.

بالإضافة إلى ذلك، فإن سحب مهمة من طابور القناة يتضمن تعديل الـ `receiver` لذا تحتاج المسارات إلى طريقة آمنة لمشاركة وتعديل `receiver`؛ وإلا فقد نحصل على حالات تسابق (race conditions) (كما تمت تغطيتها في الفصل 16).

تذكر المؤشرات الذكية الآمنة للمسارات التي نوقشت في الفصل 16: لمشاركة الملكية عبر مسارات متعددة والسماح للمسارات بتعديل القيمة، نحتاج إلى استخدام `Arc<Mutex<T>>`. سيسمح نوع `Arc` لنسخ `Worker` متعددة بامتلاك المستقبل، وسيضمن `Mutex` أن عاملاً واحداً فقط يحصل على مهمة من المستقبل في كل مرة. توضح القائمة 21-18 التغييرات التي نحتاج إلى إجرائها.

<Listing number="21-18" file-name="src/lib.rs" caption="مشاركة المستقبل بين نسخ Worker باستخدام Arc و Mutex">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/listing-21-18/src/lib.rs:here}}
```

</Listing>

في `ThreadPool::new` نضع المستقبل في `Arc` و `Mutex`. لكل `Worker` جديد، نقوم باستنساخ الـ `Arc` لزيادة عدد المراجع بحيث يمكن لنسخ `Worker` مشاركة ملكية المستقبل.

مع هذه التغييرات، يتم تجميع الكود! نحن نقترب!

#### تنفيذ دالة `execute`

دعونا أخيراً ننفذ دالة `execute` على `ThreadPool`. سنقوم أيضاً بتغيير `Job` من هيكل إلى اسم مستعار للنوع (type alias) لكائن سمة (trait object) يحمل نوع الإغلاق الذي تستقبله `execute`. كما نوقش في قسم ["مرادفات الأنواع وأسماء الأنواع المستعارة"][type-aliases] في الفصل 20، تسمح لنا أسماء الأنواع المستعارة بجعل الأنواع الطويلة أقصر لسهولة الاستخدام. انظر إلى القائمة 21-19.

<Listing number="21-19" file-name="src/lib.rs" caption="إنشاء اسم مستعار للنوع Job لـ Box يحمل كل إغلاق ثم إرسال المهمة عبر القناة">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/listing-21-19/src/lib.rs:here}}
```

</Listing>

بعد إنشاء نسخة `Job` جديدة باستخدام الإغلاق الذي نحصل عليه في `execute` نرسل تلك المهمة عبر طرف الإرسال في القناة. نحن نستدعي `unwrap` على `send` للحالة التي يفشل فيها الإرسال. قد يحدث هذا إذا قمنا، على سبيل المثال، بإيقاف جميع مساراتنا عن التنفيذ، مما يعني أن طرف الاستقبال قد توقف عن استقبال رسائل جديدة. في الوقت الحالي، لا يمكننا إيقاف مساراتنا عن التنفيذ: تستمر مساراتنا في التنفيذ طالما أن الحوض موجود. السبب في استخدامنا لـ `unwrap` هو أننا نعلم أن حالة الفشل لن تحدث، لكن المترجم لا يعرف ذلك.

لكننا لم ننتهِ تماماً بعد! في الـ `Worker` لا يزال الإغلاق الذي يتم تمريره إلى `thread::spawn` يشير فقط إلى طرف الاستقبال في القناة. بدلاً من ذلك، نحتاج إلى أن يدخل الإغلاق في حلقة تكرار للأبد، يطلب من طرف الاستقبال في القناة مهمة ويقوم بتشغيل المهمة عندما يحصل على واحدة. دعونا نجري التغيير الموضح في القائمة 21-20 على `Worker::new`.

<Listing number="21-20" file-name="src/lib.rs" caption="استقبال وتنفيذ المهام في مسار نسخة Worker">

```rust,noplayground
{{#rustdoc_include ../listings/ch21-web-server/listing-21-20/src/lib.rs:here}}
```

</Listing>

هنا، نستدعي أولاً `lock` على الـ `receiver` للحصول على الـ mutex، ثم نستدعي `unwrap` للهلع (panic) عند حدوث أي أخطاء. قد يفشل الحصول على القفل إذا كان الـ mutex في حالة _مسمومة_ (poisoned)، والتي يمكن أن تحدث إذا هلع مسار آخر أثناء امتلاك القفل بدلاً من تحريره. في هذه الحالة، استدعاء `unwrap` لجعل هذا المسار يهلع هو الإجراء الصحيح الذي يجب اتخاذه. لا تتردد في تغيير `unwrap` هذه إلى `expect` مع رسالة خطأ ذات معنى بالنسبة لك.

إذا حصلنا على القفل في الـ mutex، فنحن نستدعي `recv` لاستقبال `Job` من القناة. استدعاء `unwrap` نهائي يتجاوز أي أخطاء هنا أيضاً، والتي قد تحدث إذا تم إغلاق المسار الذي يحمل المرسل، على غرار كيفية إرجاع دالة `send` لـ `Err` إذا تم إغلاق المستقبل.

استدعاء `recv` يحجب التنفيذ (blocks)، لذا إذا لم تكن هناك مهمة بعد، فسوف ينتظر المسار الحالي حتى تصبح المهمة متاحة. يضمن `Mutex<T>` أن مسار `Worker` واحداً فقط في كل مرة يحاول طلب مهمة.

حوض المسارات الخاص بنا الآن في حالة عمل! جربه باستخدام `cargo run` وقم بإجراء بعض الطلبات:

<!-- manual-regeneration
cd listings/ch21-web-server/listing-21-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->

```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field `workers` is never read
 --> src/lib.rs:7:5
  |
6 | pub struct ThreadPool {
  |            ---------- field in this struct
7 |     workers: Vec<Worker>,
  |     ^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `id` and `thread` are never read
  --> src/lib.rs:48:5
   |
47 | struct Worker {
   |        ------ fields in this struct
48 |     id: usize,
   |     ^^
49 |     thread: thread::JoinHandle<()>,
   |     ^^^^^^

warning: `hello` (lib) generated 2 warnings
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 4.91s
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
```

نجاح! لدينا الآن حوض مسارات ينفذ الاتصالات بشكل غير متزامن. لا يتم إنشاء أكثر من أربعة مسارات أبداً، لذا لن يتعرض نظامنا للحمل الزائد إذا تلقى الخادم الكثير من الطلبات. إذا قدمنا طلباً إلى _/sleep_، فسيكون الخادم قادراً على خدمة الطلبات الأخرى عن طريق جعل مسار آخر يقوم بتشغيلها.

> ملاحظة: إذا فتحت _/sleep_ في نوافذ متصفح متعددة في وقت واحد، فقد يتم تحميلها واحدة تلو الأخرى في فترات زمنية مدتها خمس ثوانٍ. تقوم بعض متصفحات الويب بتنفيذ نسخ متعددة من نفس الطلب بشكل تسلسلي لأسباب تتعلق بالتخزين المؤقت (caching). هذا القيد لا يسببه خادم الويب الخاص بنا.

هذا وقت جيد للتوقف والتفكير في كيف سيكون الكود في القوائم 21-18 و 21-19 و 21-20 مختلفاً إذا كنا نستخدم الـ futures بدلاً من الإغلاق للعمل الذي يتعين القيام به. ما هي الأنواع التي ستتغير؟ كيف ستكون تواقيع الدوال مختلفة، إن وجدت؟ ما هي أجزاء الكود التي ستبقى كما هي؟

بعد التعرف على حلقة `while let` في الفصل 17 والفصل 19، قد تتساءل لماذا لم نكتب كود مسار `Worker` كما هو موضح في القائمة 21-21.

<Listing number="21-21" file-name="src/lib.rs" caption="تنفيذ بديل لـ Worker::new باستخدام while let">

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch21-web-server/listing-21-21/src/lib.rs:here}}
```

</Listing>

هذا الكود يتم تجميعه وتشغيله ولكنه لا يؤدي إلى سلوك المسارات المطلوب: سيظل الطلب البطيء يتسبب في انتظار الطلبات الأخرى للمعالجة. السبب دقيق نوعاً ما: هيكل `Mutex` لا يحتوي على دالة `unlock` عامة لأن ملكية القفل تعتمد على عمر `MutexGuard<T>` داخل `LockResult<MutexGuard<T>>` الذي تعيده دالة `lock`. في وقت التجميع، يمكن لمدقق الاستعارة (borrow checker) بعد ذلك فرض القاعدة التي تنص على أنه لا يمكن الوصول إلى مورد يحميه `Mutex` ما لم نكن نمتلك القفل. ومع ذلك، يمكن أن يؤدي هذا التنفيذ أيضاً إلى الاحتفاظ بالقفل لفترة أطول من المقصود إذا لم نكن منتبهين لعمر `MutexGuard<T>`.

الكود في القائمة 21-20 الذي يستخدم `let job = receiver.lock().unwrap().recv().unwrap();` يعمل لأنه مع `let` يتم إسقاط أي قيم مؤقتة مستخدمة في التعبير على الجانب الأيمن من علامة التساوي فور انتهاء عبارة `let`. ومع ذلك، فإن `while let` (و `if let` و `match`) لا تسقط القيم المؤقتة حتى نهاية الكتلة المرتبطة. في القائمة 21-21، يظل القفل ممسوكاً طوال مدة استدعاء `job()`، مما يعني أن نسخ `Worker` الأخرى لا يمكنها استقبال المهام.

[type-aliases]: ch20-03-advanced-types.html#type-synonyms-and-type-aliases
[integer-types]: ch03-02-data-types.html#integer-types
[moving-out-of-closures]: ch13-01-closures.html#moving-captured-values-out-of-closures
[builder]: ../std/thread/struct.Builder.html
[builder-spawn]: ../std/thread/struct.Builder.html#method.spawn
