# مقدمة (Introduction)

> ملاحظة: هذه الطبعة من الكتاب هي نفسها طبعة [لغة البرمجة رست (The Rust Programming Language)][nsprust] المتوفرة في شكل مطبوع وكتاب إلكتروني من [No Starch Press][nsp].

[nsprust]: https://nostarch.com/rust-programming-language-3rd-edition
[nsp]: https://nostarch.com/

مرحباً بكم في كتاب _لغة البرمجة رست_، وهو كتاب تمهيدي حول Rust. تساعدك لغة البرمجة Rust على كتابة برمجيات أسرع وأكثر موثوقية. غالباً ما تتعارض بيئة العمل عالية المستوى (High-level ergonomics) والتحكم منخفض المستوى (low-level control) في تصميم لغات البرمجة؛ وتتحدى Rust هذا الصراع. من خلال الموازنة بين القدرة التقنية القوية وتجربة المطور الرائعة، تمنحك Rust خيار التحكم في التفاصيل منخفضة المستوى (مثل استخدام الذاكرة (memory usage)) دون كل العناء المرتبط تقليدياً بهذا التحكم.

## لمن صُممت Rust

تعد Rust مثالية للعديد من الأشخاص لمجموعة متنوعة من الأسباب. دعونا نلقي نظرة على عدد قليل من أهم المجموعات.

### فرق المطورين (Teams of Developers)

تثبت Rust أنها أداة إنتاجية للتعاون بين فرق كبيرة من المطورين الذين لديهم مستويات متفاوتة من المعرفة ببرمجة الأنظمة (systems programming). الكود منخفض المستوى عرضة للعديد من الأخطاء البرمجية (bugs) الدقيقة، والتي لا يمكن اكتشافها في معظم اللغات الأخرى إلا من خلال الاختبار المكثف ومراجعة الكود (code review) الدقيقة من قبل مطورين ذوي خبرة. في Rust، يلعب المصرف (compiler) دور الحارس من خلال رفض تصريف (compile) الكود الذي يحتوي على هذه الأخطاء المراوغة، بما في ذلك أخطاء التزامن (concurrency bugs). من خلال العمل جنباً إلى جنب مع compiler، يمكن للفريق قضاء وقته في التركيز على منطق البرنامج بدلاً من مطاردة bugs.

تجلب Rust أيضاً أدوات مطورين معاصرة إلى عالم برمجة الأنظمة:

- Cargo، وهو مدير الاعتمادات (dependency manager) وأداة البناء (build tool) المضمنة، يجعل إضافة الاعتمادات (dependencies) وتصريفها وإدارتها أمراً سهلاً ومتسقاً عبر نظام Rust البيئي (ecosystem).
- أداة التنسيق `rustfmt` تضمن أسلوب ترميز (coding style) متسقاً بين المطورين.
- خادم لغة رست (Rust Language Server) يدعم تكامل بيئة التطوير المتكاملة (IDE) لإكمال الكود ورسائل الخطأ المضمنة.

باستخدام هذه الأدوات وغيرها في نظام Rust البيئي، يمكن للمطورين أن يكونوا منتجين أثناء كتابة كود على مستوى الأنظمة.

### الطلاب (Students)

Rust مخصصة للطلاب وأولئك المهتمين بالتعرف على مفاهيم الأنظمة. باستخدام Rust، تعلم الكثير من الناس مواضيع مثل تطوير أنظمة التشغيل. المجتمع مضياف للغاية ويسعده الإجابة على أسئلة الطلاب. من خلال جهود مثل هذا الكتاب، تريد فرق Rust جعل مفاهيم الأنظمة أكثر سهولة لمزيد من الناس، وخاصة الجدد في البرمجة.

### الشركات (Companies)

تستخدم مئات الشركات، الكبيرة والصغيرة، Rust في الإنتاج لمجموعة متنوعة من المهام، بما في ذلك أدوات سطر الأوامر (command line tools)، وخدمات الويب، وأدوات العمليات البرمجية (DevOps tooling)، والأجهزة المدمجة (embedded devices)، وتحليل وترميز الصوت والفيديو، والعملات المشفرة، والمعلوماتية الحيوية، ومحركات البحث، وتطبيقات إنترنت الأشياء (Internet of Things)، والتعلم الآلي (machine learning)، وحتى أجزاء رئيسية من متصفح الويب Firefox.

### مطورو البرمجيات مفتوحة المصدر (Open Source Developers)

Rust مخصصة للأشخاص الذين يرغبون في بناء لغة البرمجة Rust، والمجتمع، وأدوات المطورين، والمكتبات (libraries). يسعدنا أن تساهم في لغة Rust.

### الأشخاص الذين يقدرون السرعة والاستقرار

Rust مخصصة للأشخاص الذين يتوقون إلى السرعة والاستقرار في اللغة. بالسرعة، نعني كلاً من مدى سرعة تشغيل كود Rust والسرعة التي تتيح لك بها Rust كتابة البرامج. تضمن فحوصات compiler في Rust الاستقرار من خلال إضافات الميزات وإعادة هيكلة الكود (refactoring). هذا على عكس الكود القديم الهش في اللغات التي لا تحتوي على هذه الفحوصات، والتي غالباً ما يخشى المطورون تعديلها. من خلال السعي وراء التجريدات صفرية التكلفة (zero-cost abstractions) — وهي ميزات عالية المستوى يتم تصريفها إلى كود منخفض المستوى بنفس سرعة الكود المكتوب يدوياً — تسعى Rust لجعل الكود الآمن كوداً سريعاً أيضاً.

تأمل لغة Rust في دعم العديد من المستخدمين الآخرين أيضاً؛ المذكورون هنا هم مجرد بعض من أكبر أصحاب المصلحة. بشكل عام، طموح Rust الأكبر هو القضاء على المقايضات التي قبلها المبرمجون لعقود من خلال توفير الأمان _و_ الإنتاجية، والسرعة _و_ سهولة الاستخدام. جرب Rust، وانظر ما إذا كانت خياراتها تناسبك.

## لمن صُمم هذا الكتاب

يفترض هذا الكتاب أنك كتبت كوداً بلغة برمجة أخرى، لكنه لا يضع أي افتراضات حول أي لغة. لقد حاولنا جعل المادة متاحة على نطاق واسع لأولئك الذين ينتمون إلى مجموعة متنوعة من الخلفيات البرمجية. نحن لا نقضي الكثير من الوقت في التحدث عما _تكون_ عليه البرمجة أو كيفية التفكير فيها. إذا كنت جديداً تماماً على البرمجة، فمن الأفضل لك قراءة كتاب يقدم خصيصاً مقدمة للبرمجة.

## كيفية استخدام هذا الكتاب

بشكل عام، يفترض هذا الكتاب أنك تقرأه بالتسلسل من البداية إلى النهاية. تبني الفصول اللاحقة على المفاهيم الواردة في الفصول السابقة، وقد لا تتعمق الفصول السابقة في تفاصيل موضوع معين ولكنها ستعيد زيارة الموضوع في فصل لاحق.

ستجد نوعين من الفصول في هذا الكتاب: فصول المفاهيم وفصول المشاريع. في فصول المفاهيم، ستتعلم عن جانب من جوانب Rust. في فصول المشاريع، سنبني برامج صغيرة معاً، ونطبق ما تعلمته حتى الآن. الفصل 2 والفصل 12 والفصل 21 هي فصول مشاريع؛ والباقي فصول مفاهيم.

يشرح **الفصل 1** كيفية تثبيت Rust، وكيفية كتابة برنامج "Hello, world!"، وكيفية استخدام Cargo، وهو مدير الحزم (package manager) وأداة البناء في Rust. **الفصل 2** هو مقدمة عملية لكتابة برنامج في Rust، حيث يجعلك تبني لعبة تخمين الأرقام. هنا، نغطي المفاهيم على مستوى عالٍ، وستوفر الفصول اللاحقة تفاصيل إضافية. إذا كنت ترغب في البدء بالتطبيق العملي على الفور، فإن الفصل 2 هو المكان المناسب لذلك. إذا كنت متعلماً دقيقاً بشكل خاص وتفضل تعلم كل التفاصيل قبل الانتقال إلى الخطوة التالية، فقد ترغب في تخطي الفصل 2 والانتقال مباشرة إلى **الفصل 3**، الذي يغطي ميزات Rust المشابهة لميزات لغات البرمجة الأخرى؛ ثم يمكنك العودة إلى الفصل 2 عندما ترغب في العمل على مشروع يطبق التفاصيل التي تعلمتها.

في **الفصل 4**، ستتعلم عن نظام الملكية (ownership system) في Rust. يناقش **الفصل 5** الهياكل (structs) والدوال (methods). يغطي **الفصل 6** التعدادات (enums)، وتعبيرات `match` ، وبنيات تدفق التحكم `if let` و `let...else`. ستستخدم structs و enums لإنشاء أنواع مخصصة.

في **الفصل 7**، ستتعلم عن نظام الوحدات (module system) في Rust وعن قواعد الخصوصية لتنظيم الكود الخاص بك وواجهة برمجة التطبيقات (API) العامة الخاصة به. يناقش **الفصل 8** بعض هياكل بيانات المجموعات (collection data structures) الشائعة التي توفرها المكتبة القياسية (standard library): المتجهات (vectors)، والسلاسل النصية (strings)، وخرائط التجزئة (hash maps). يستكشف **الفصل 9** فلسفة وتقنيات معالجة الأخطاء (error-handling) في Rust.

يتعمق **الفصل 10** في الأنواع العامة (generics)، والسمات (traits)، وفترات الحياة (lifetimes)، والتي تمنحك القدرة على تعريف كود ينطبق على أنواع متعددة. **الفصل 11** يدور حول الاختبار (testing)، والذي حتى مع ضمانات الأمان في Rust يعد ضرورياً لضمان صحة منطق برنامجك. في **الفصل 12**، سنبني تنفيذنا الخاص لمجموعة فرعية من الوظائف من أداة سطر الأوامر `grep` التي تبحث عن نص داخل الملفات. لهذا، سنستخدم العديد من المفاهيم التي ناقشناها في الفصول السابقة.

يستكشف **الفصل 13** الإغلاقات (closures) والمكررات (iterators): ميزات Rust التي تأتي من لغات البرمجة الوظيفية (functional programming languages). في **الفصل 14**، سنفحص Cargo بمزيد من العمق ونتحدث عن أفضل الممارسات لمشاركة مكتباتك مع الآخرين. يناقش **الفصل 15** المؤشرات الذكية (smart pointers) التي توفرها standard library والسمات التي تمكن وظائفها.

في **الفصل 16**، سنستعرض نماذج مختلفة من البرمجة المتزامنة (concurrent programming) ونتحدث عن كيفية مساعدة Rust لك في البرمجة في خيوط معالجة (threads) متعددة دون خوف. في **الفصل 17**، نبني على ذلك من خلال استكشاف بناء جملة async و await في Rust، جنباً إلى جنب مع المهام (tasks)، والمستقبليات (futures)، والمجاري (streams)، ونموذج التزامن خفيف الوزن الذي تمكنه.

ينظر **الفصل 18** في كيفية مقارنة اصطلاحات (idioms) Rust بمبادئ البرمجة كائنية التوجه التي قد تكون مألوفاً بها. **الفصل 19** هو مرجع حول الأنماط (patterns) ومطابقة الأنماط (pattern matching)، وهي طرق قوية للتعبير عن الأفكار عبر برامج Rust. يحتوي **الفصل 20** على مجموعة متنوعة من المواضيع المتقدمة ذات الأهمية، بما في ذلك Rust غير الآمنة (unsafe Rust)، والماكرو (macros)، والمزيد حول lifetimes و traits والأنواع والدوال و closures.

في **الفصل 21**، سنكمل مشروعاً سنقوم فيه بتنفيذ خادم ويب متعدد الخيوط منخفض المستوى!

أخيراً، تحتوي بعض الملاحق على معلومات مفيدة حول اللغة في شكل مرجعي أكثر. يغطي **الملحق أ** الكلمات المفتاحية (keywords) في Rust، ويغطي **الملحق ب** العمليات والرموز، ويغطي **الملحق ج** السمات القابلة للاشتقاق (derivable traits) التي توفرها standard library، ويغطي **الملحق د** بعض أدوات التطوير المفيدة، ويشرح **الملحق هـ** إصدارات (editions) Rust. في **الملحق و**، يمكنك العثور على ترجمات للكتاب، وفي **الملحق ز** سنغطي كيفية صنع Rust وما هي نسخة nightly من Rust.

لا توجد طريقة خاطئة لقراءة هذا الكتاب: إذا كنت تريد التخطي للأمام، فافعل ذلك! قد تضطر إلى العودة إلى الفصول السابقة إذا واجهت أي ارتباك. لكن افعل ما يناسبك.

<span id="ferris"></span>

جزء مهم من عملية تعلم Rust هو تعلم كيفية قراءة رسائل الخطأ التي يعرضها compiler: ستوجهك هذه الرسائل نحو الكود الذي يعمل. على هذا النحو، سنقدم العديد من الأمثلة التي لا يتم تصريفها جنباً إلى جنب مع رسالة الخطأ التي سيظهرها لك compiler في كل موقف. اعلم أنك إذا أدخلت وشغلت مثالاً عشوائياً، فقد لا يتم تصريفه! تأكد من قراءة النص المحيط لمعرفة ما إذا كان المثال الذي تحاول تشغيله يهدف إلى إظهار خطأ. في معظم الحالات، سنقودك إلى النسخة الصحيحة من أي كود لا يتم تصريفه. سيساعدك Ferris أيضاً في تمييز الكود الذي لا يُقصد منه العمل:

| Ferris                                                                                                           | المعنى                                          |
| ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain" alt="Ferris with a question mark"/>            | هذا الكود لا يتم تصريفه!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain" alt="Ferris throwing up their hands"/>                   | هذا الكود يسبب هلعاً (panics)!                                |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain" alt="Ferris with one claw up, shrugging"/> | هذا الكود لا ينتج السلوك المطلوب. |

في معظم الحالات، سنقودك إلى النسخة الصحيحة من أي كود لا يتم تصريفه.

## الكود المصدري (Source Code)

يمكن العثور على الملفات المصدرية التي تم إنشاء هذا الكتاب منها على [GitHub][book].

[book]: https://github.com/rust-lang/book/tree/main/src
