## الملحق هـ: الإصدارات (Editions)

في الفصل الأول، رأيت أن الأمر `cargo new` يضيف بعض البيانات الوصفية (metadata) إلى ملف `_Cargo.toml_` الخاص بك حول إصدار (edition). يتحدث هذا الملحق عما يعنيه ذلك!

تتمتع لغة Rust والمُصرِّف (compiler) بدورة إصدار مدتها ستة أسابيع، مما يعني أن المستخدمين يحصلون على تدفق مستمر من الميزات الجديدة. تطلق لغات البرمجة الأخرى تغييرات أكبر بوتيرة أقل؛ بينما تطلق Rust تحديثات أصغر بشكل متكرر. بعد فترة من الزمن، تتراكم كل هذه التغييرات الصغيرة. ولكن من إصدار إلى إصدار، قد يكون من الصعب النظر إلى الوراء والقول: "واو، بين Rust 1.10 و Rust 1.31، تغيرت Rust كثيرًا!"

كل ثلاث سنوات تقريبًا، ينتج فريق Rust إصدار (edition) جديدًا للغة Rust. يجمع كل edition الميزات التي تم إطلاقها في حزمة واضحة مع توثيق وأدوات (tooling) محدثة بالكامل. يتم شحن الإصدارات الجديدة كجزء من عملية الإصدار المعتادة التي تستغرق ستة أسابيع.

تخدم editions أغراضًا مختلفة لأشخاص مختلفين:

- بالنسبة لمستخدمي Rust النشطين، يجمع edition جديد التغييرات التدريجية في حزمة سهلة الفهم.
- بالنسبة لغير المستخدمين، يشير edition جديد إلى أن بعض التطورات الرئيسية قد تحققت، مما قد يجعل Rust تستحق نظرة أخرى.
- بالنسبة لأولئك الذين يطورون Rust، يوفر edition جديد نقطة تجمع للمشروع ككل.

في وقت كتابة هذا الكتاب، تتوفر أربعة Rust editions: Rust 2015، Rust 2018، Rust 2021، و Rust 2024. كُتب هذا الكتاب باستخدام مصطلحات (idioms) edition Rust 2024.

يشير مفتاح `edition` في `_Cargo.toml_` إلى أي edition يجب أن يستخدمه compiler لـ code الخاص بك. إذا لم يكن المفتاح موجودًا، تستخدم Rust القيمة `2015` كقيمة edition لأسباب تتعلق بالتوافق مع الإصدارات السابقة (backward compatibility).

يمكن لكل مشروع اختيار edition بخلاف edition 2015 الافتراضي. يمكن أن تحتوي editions على تغييرات غير متوافقة، مثل تضمين كلمة مفتاحية (keyword) جديدة تتعارض مع المعرفات (identifiers) في code. ومع ذلك، ما لم تختر هذه التغييرات، سيستمر code الخاص بك في أن يُصرَّف (compile) حتى مع ترقية إصدار compiler الذي تستخدمه.

تدعم جميع إصدارات compiler الخاصة بـ Rust أي edition كان موجودًا قبل إصدار ذلك compiler، ويمكنها ربط الحزم (crates) من أي editions مدعومة معًا. تؤثر تغييرات edition فقط على طريقة قيام compiler بتحليل الشفرة (code) في البداية. لذلك، إذا كنت تستخدم Rust 2015 وتستخدم إحدى التبعيات (dependency) الخاصة بك Rust 2018، فسيتم compile مشروعك وستتمكن من استخدام تلك dependency. يعمل الوضع المعاكس أيضًا، حيث يستخدم مشروعك Rust 2018 وتستخدم dependency إصدار Rust 2015.

لتوضيح الأمر: ستكون معظم الميزات متاحة في جميع editions. سيستمر المطورون الذين يستخدمون أي Rust edition في رؤية التحسينات مع إصدار نسخ مستقرة جديدة. ومع ذلك، في بعض الحالات، خاصة عند إضافة keywords جديدة، قد تكون بعض الميزات الجديدة متاحة فقط في editions اللاحقة. ستحتاج إلى تبديل editions إذا كنت ترغب في الاستفادة من هذه الميزات.

لمزيد من التفاصيل، راجع [_دليل إصدار Rust_][edition-guide]. هذا كتاب كامل يسرد الاختلافات بين editions ويوضح كيفية ترقية code الخاص بك تلقائيًا إلى edition جديد عبر الأمر `cargo fix`.

[edition-guide]: https://doc.rust-lang.org/stable/edition-guide
