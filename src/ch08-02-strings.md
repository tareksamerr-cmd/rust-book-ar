## تخزين النصوص المشفرة بـ UTF-8 باستخدام السلاسل النصية (Strings)

تحدثنا عن السلاسل النصية (Strings) في الفصل 4، لكننا سنلقي نظرة عليها بعمق أكبر الآن. عادةً ما يواجه المبرمجون الجدد في Rust (Rustaceans) صعوبة في التعامل مع الـ Strings لثلاثة أسباب مجتمعة: ميل Rust لإظهار الأخطاء المحتملة، وكون الـ Strings هيكل بيانات أكثر تعقيداً مما يعتقده الكثير من المبرمجين، و UTF-8. تجتمع هذه العوامل بطريقة قد تبدو صعبة عندما تأتي من لغات برمجة أخرى.

نناقش الـ Strings في سياق المجموعات (Collections) لأن الـ Strings يتم تنفيذها كمجموعة من البايتات (Bytes)، بالإضافة إلى بعض الدوال المرتبطة (Methods) لتوفير وظائف مفيدة عندما يتم تفسير تلك الـ Bytes كنص. في هذا القسم، سنتحدث عن العمليات على `String` التي تمتلكها كل أنواع الـ Collections، مثل الإنشاء والتحديث والقراءة. سنناقش أيضاً الطرق التي تختلف بها `String` عن الـ Collections الأخرى، وتحديداً كيف أن الفهرسة (Indexing) في `String` معقدة بسبب الاختلافات بين كيفية تفسير البشر والحواسيب لبيانات الـ `String`.

<!-- Old headings. Do not remove or links may break. -->

<a id="what-is-a-string"></a>

### تعريف السلاسل النصية (Defining Strings)

سنعرف أولاً ما نعنيه بمصطلح *String*. تمتلك Rust نوعاً واحداً فقط من السلاسل النصية في لغتها الأساسية (Core Language)، وهو شريحة السلسلة النصية (String Slice) `str` والتي تُرى عادةً في شكلها المستعار `&str`. في الفصل 4، تحدثنا عن الـ String Slices، وهي مراجع (References) لبعض بيانات النصوص المشفرة بـ UTF-8 والمخزنة في مكان آخر. السلاسل النصية الثابتة (String Literals)، على سبيل المثال، يتم تخزينها في الملف الثنائي (Binary) للبرنامج وبالتالي فهي String Slices.

نوع `String` الذي توفره مكتبة Rust القياسية (Standard Library) بدلاً من كونه مدمجاً في الـ Core Language، هو نوع سلسلة نصية قابل للنمو، وقابل للتغيير (Mutable)، ومملوك (Owned)، ومشفر بـ UTF-8. عندما يشير الـ Rustaceans إلى "Strings" في Rust، فقد يقصدون إما نوع `String` أو نوع الـ String Slice `&str` وليس أحدهما فقط. على الرغم من أن هذا القسم يدور بشكل كبير حول `String` إلا أن كلا النوعين يستخدمان بكثافة في الـ Standard Library، وكلاهما مشفر بـ UTF-8.

### إنشاء سلسلة نصية جديدة (Creating a New String)

تتوفر العديد من العمليات المتاحة مع `Vec<T>` لـ `String` أيضاً لأن `String` يتم تنفيذها فعلياً كغلاف حول متجه من البايتات (Vector of Bytes) مع بعض الضمانات والقيود والقدرات الإضافية. مثال على دالة تعمل بنفس الطريقة مع `Vec<T>` و `String` هي دالة `new` لإنشاء نسخة (Instance)، كما هو موضح في القائمة 8-11.

<Listing number="8-11" caption="إنشاء String جديدة فارغة">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-11/src/main.rs:here}}
```

</Listing>

يُنشئ هذا السطر سلسلة نصية جديدة فارغة تسمى `s` والتي يمكننا لاحقاً تحميل البيانات فيها. غالباً ما يكون لدينا بعض البيانات الأولية التي نريد بدء السلسلة النصية بها. لذلك، نستخدم Method تسمى `to_string` والمتاحة لأي نوع ينفذ سمة `Display` (Trait) كما تفعل الـ String Literals. توضح القائمة 8-12 مثالين.

<Listing number="8-12" caption="استخدام to_string لإنشاء String من String Literal">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-12/src/main.rs:here}}
```

</Listing>

ينشئ هذا الكود سلسلة نصية تحتوي على `initial contents`.

يمكننا أيضاً استخدام الدالة `String::from` لإنشاء `String` من String Literal. الكود في القائمة 8-13 يعادل الكود في القائمة 8-12 الذي يستخدم `to_string`.

<Listing number="8-13" caption="استخدام الدالة String::from لإنشاء String من String Literal">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-13/src/main.rs:here}}
```

</Listing>

لأن الـ Strings تستخدم لأشياء كثيرة، يمكننا استخدام العديد من الواجهات البرمجية العامة (Generic APIs) المختلفة لها، مما يوفر لنا الكثير من الخيارات. قد يبدو بعضها زائداً عن الحاجة، لكن لكل منها مكانه! في هذه الحالة، تقوم `String::from` و `to_string` بنفس الشيء، لذا فإن اختيار أحدهما هو مسألة أسلوب ووضوح للقراءة.

تذكر أن الـ Strings مشفرة بـ UTF-8، لذا يمكننا تضمين أي بيانات مشفرة بشكل صحيح فيها، كما هو موضح في القائمة 8-14.

<Listing number="8-14" caption="تخزين التحيات بلغات مختلفة في Strings">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:here}}
```

</Listing>

كل هذه قيم `String` صالحة.

### تحديث سلسلة نصية (Updating a String)

يمكن لـ `String` أن تنمو في الحجم ويمكن أن تتغير محتوياتها، تماماً مثل محتويات `Vec<T>` إذا قمت بدفع (Push) المزيد من البيانات إليها. بالإضافة إلى ذلك، يمكنك استخدام عامل `+` أو ماكرو `format!` لدمج (Concatenate) قيم `String` بسهولة.

<!-- Old headings. Do not remove or links may break. -->

<a id="appending-to-a-string-with-push_str-and-push"></a>

#### الإلحاق باستخدام `push_str` أو `push`

يمكننا زيادة حجم `String` باستخدام `push_str` لإلحاق String Slice، كما هو موضح في القائمة 8-15.

<Listing number="8-15" caption="إلحاق String Slice بـ String باستخدام push_str">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-15/src/main.rs:here}}
```

</Listing>

بعد هذين السطرين، ستحتوي `s` على `foobar`. تأخذ `push_str` شريحة نصية لأننا لا نريد بالضرورة أخذ ملكية (Ownership) المعامل. على سبيل المثال، في الكود في القائمة 8-16، نريد أن نكون قادرين على استخدام `s2` بعد إلحاق محتوياتها بـ `s1`.

<Listing number="8-16" caption="استخدام String Slice بعد إلحاق محتوياتها بـ String">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-16/src/main.rs:here}}
```

</Listing>

إذا كانت `push_str` تأخذ Ownership لـ `s2` فلن نتمكن من طباعة قيمتها في السطر الأخير. ومع ذلك، يعمل هذا الكود كما نتوقع!

تأخذ Method الـ `push` حرفاً واحداً كمعامل وتضيفه إلى الـ `String`. تضيف القائمة 8-17 الحرف *l* إلى `String` باستخدام `push`.

<Listing number="8-17" caption="إضافة حرف واحد لقيمة String باستخدام push">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-17/src/main.rs:here}}
```

</Listing>

نتيجة لذلك، ستحتوي `s` على `lol`.

<!-- Old headings. Do not remove or links may break. -->

<a id="concatenation-with-the--operator-or-the-format-macro"></a>

#### الدمج باستخدام `+` أو `format!`

غالباً ما ستحتاج إلى دمج سلسلتين نصيتين موجودتين. إحدى الطرق للقيام بذلك هي استخدام عامل `+` كما هو موضح في القائمة 8-18.

<Listing number="8-18" caption="استخدام عامل + لدمج قيمتي String في قيمة String جديدة">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-18/src/main.rs:here}}
```

</Listing>

ستحتوي السلسلة `s3` على `Hello, world!`. السبب في أن `s1` لم تعد صالحة بعد الإضافة، والسبب في استخدامنا لمرجع لـ `s2` يتعلق بتوقيع (Signature) الـ Method التي يتم استدعاؤها عند استخدام عامل `+`. يستخدم عامل `+` دالة `add` التي يبدو توقيعها كالتالي:

```rust,ignore
fn add(self, s: &str) -> String {
```

في الـ Standard Library، سترى `add` معرفة باستخدام الأنواع العامة (Generics) والأنواع المرتبطة (Associated Types). هنا، قمنا باستبدالها بأنواع ملموسة (Concrete Types)، وهو ما يحدث عندما نستدعي هذه الـ Method بقيم `String`. سنناقش الـ Generics في الفصل 10. يعطينا هذا الـ Signature الأدلة التي نحتاجها لفهم الأجزاء المعقدة في عامل `+`.

أولاً، تمتلك `s2` علامة `&` مما يعني أننا نضيف Reference للسلسلة الثانية إلى السلسلة الأولى. هذا بسبب معامل `s` في دالة `add`: يمكننا فقط إضافة String Slice إلى `String`؛ لا يمكننا إضافة قيمتي `String` معاً. ولكن انتظر—نوع `&s2` هو `&String` وليس `&str` كما هو محدد في المعامل الثاني لـ `add`. إذاً، لماذا يتم تجميع القائمة 8-18؟

السبب في قدرتنا على استخدام `&s2` في استدعاء `add` هو أن المترجم (Compiler) يمكنه إجبار (Coerce) معامل الـ `&String` ليصبح `&str`. عندما نستدعي `add` تستخدم Rust "إجبار إلغاء الإسناد" (Deref Coercion)، والذي يحول هنا `&s2` إلى `&s2[..]`. سنناقش الـ Deref Coercion بعمق أكبر في الفصل 15. ولأن `add` لا تأخذ Ownership لمعامل `s` ستظل `s2` قيمة `String` صالحة بعد هذه العملية.

ثانياً، يمكننا أن نرى في الـ Signature أن `add` تأخذ Ownership لـ `self` لأن `self` *لا* تمتلك علامة `&`. هذا يعني أن `s1` في القائمة 8-18 سيتم نقلها (Moved) إلى استدعاء `add` ولن تعد صالحة بعد ذلك. لذا، على الرغم من أن `let s3 = s1 + &s2;` تبدو وكأنها ستنسخ كلتا السلسلتين وتنشئ واحدة جديدة، إلا أن هذه العبارة تأخذ في الواقع Ownership لـ `s1` وتلحق بها نسخة من محتويات `s2` ثم تعيد Ownership للنتيجة. بعبارة أخرى، يبدو الأمر وكأنه يتم إجراء الكثير من النسخ، لكنه ليس كذلك؛ التنفيذ أكثر كفاءة من النسخ.

إذا احتجنا لدمج سلاسل نصية متعددة، يصبح سلوك عامل `+` غير مريح:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-01-concat-multiple-strings/src/main.rs:here}}
```

عند هذه النقطة، ستكون `s` هي `tic-tac-toe`. مع كل علامات `+` و `"` يصبح من الصعب رؤية ما يحدث. لدمج السلاسل النصية بطرق أكثر تعقيداً، يمكننا بدلاً من ذلك استخدام ماكرو `format!`:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-02-format/src/main.rs:here}}
```

يضبط هذا الكود أيضاً `s` لتكون `tic-tac-toe`. يعمل ماكرو `format!` مثل `println!` ولكن بدلاً من طباعة المخرجات على الشاشة، فإنه يعيد `String` بالمحتويات. نسخة الكود التي تستخدم `format!` أسهل بكثير في القراءة، والكود الناتج عن ماكرو `format!` يستخدم مراجع (References) بحيث لا يأخذ هذا الاستدعاء Ownership لأي من معاملاته.

### الفهرسة في السلاسل النصية (Indexing into Strings)

في العديد من لغات البرمجة الأخرى، يعد الوصول إلى أحرف فردية في سلسلة نصية عن طريق الإشارة إليها بالفهرس (Index) عملية صالحة وشائعة. ومع ذلك، إذا حاولت الوصول إلى أجزاء من `String` باستخدام صيغة الفهرسة في Rust، فستحصل على خطأ. فكر في الكود غير الصالح في القائمة 8-19.

<Listing number="8-19" caption="محاولة استخدام صيغة الفهرسة مع String">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-19/src/main.rs:here}}
```

</Listing>

سيؤدي هذا الكود إلى الخطأ التالي:

```console
{{#include ../listings/ch08-common-collections/listing-08-19/output.txt}}
```

الخطأ يوضح القصة: الـ Strings في Rust لا تدعم الـ Indexing. ولكن لماذا لا؟ للإجابة على هذا السؤال، نحتاج إلى مناقشة كيفية تخزين Rust للـ Strings في الذاكرة.

#### التمثيل الداخلي (Internal Representation)

الـ `String` هي غلاف فوق `Vec<u8>`. دعنا ننظر في بعض أمثلة السلاسل النصية المشفرة بـ UTF-8 من القائمة 8-14. أولاً، هذه:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:spanish}}
```

في هذه الحالة، سيكون `len` هو `4` مما يعني أن الـ Vector الذي يخزن السلسلة `"Hola"` طوله 4 بايتات. كل حرف من هذه الأحرف يأخذ 1 بايت عند تشفيره بـ UTF-8. ماذا عن السطر التالي؟

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-14/src/main.rs:russian}}
```

إذا سُئلت عن طول السلسلة، فقد تقول 12. في الواقع، إجابة Rust هي 24: هذا هو عدد البايتات التي يتطلبها تشفير "Здравствуйте" بـ UTF-8، لأن كل قيمة سلمية لليونيكود (Unicode Scalar Value) في تلك السلسلة تأخذ 2 بايت من التخزين. لذلك، فإن الفهرس في بايتات السلسلة لن يرتبط دائماً بـ Unicode Scalar Value صالحة. للتوضيح، فكر في كود Rust غير الصالح هذا:

```rust,ignore,does_not_compile
let hello = "Здравствуйте";
let answer = &hello[0];
```

أنت تعلم بالفعل أن `answer` لن تكون `З` (الحرف الأول). عند التشفير بـ UTF-8، يكون البايت الأول من `З` هو `208` والثاني هو `151` لذا يبدو أن `answer` يجب أن تكون في الواقع `208` لكن `208` ليس حرفاً صالحاً بمفرده. من المحتمل ألا يكون إرجاع `208` هو ما يريده المستخدم إذا طلب الحرف الأول من هذه السلسلة؛ ومع ذلك، فهذه هي البيانات الوحيدة التي تمتلكها Rust عند فهرس البايت 0. لا يريد المستخدمون عموماً إرجاع قيمة البايت، حتى لو كانت السلسلة تحتوي فقط على أحرف لاتينية: إذا كان `&"hi"[0]` كوداً صالحاً يعيد قيمة البايت، فإنه سيعيد `104` وليس `h`.

الإجابة إذاً هي أنه لتجنب إرجاع قيمة غير متوقعة والتسبب في أخطاء قد لا يتم اكتشافها على الفور، لا تقوم Rust بتجميع هذا الكود على الإطلاق وتمنع سوء الفهم في وقت مبكر من عملية التطوير.

<!-- Old headings. Do not remove or links may break. -->

<a id="bytes-and-scalar-values-and-grapheme-clusters-oh-my"></a>

#### البايتات، والقيم السلمية، وعناقيد الرموز (Bytes, Scalar Values, and Grapheme Clusters)

نقطة أخرى حول UTF-8 هي أن هناك في الواقع ثلاث طرق ذات صلة للنظر في الـ Strings من منظور Rust: كبايتات (Bytes)، وقيم سلمية (Scalar Values)، وعناقيد رموز (Grapheme Clusters) - وهي أقرب شيء لما نسميه *أحرفاً*.

إذا نظرنا إلى الكلمة الهندية "नमस्ते" المكتوبة بخط الديفاناغاري، فسيتم تخزينها كمتجه من قيم `u8` يبدو كالتالي:

```text
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
```

هذا يمثل 18 بايت وهو الكيفية التي تخزن بها الحواسيب هذه البيانات في النهاية. إذا نظرنا إليها كـ Unicode Scalar Values، وهي ما يمثله نوع `char` في Rust، فستبدو تلك البايتات كالتالي:

```text
['न', 'م', 'س', '्', 'ت', 'े']
```

هناك ست قيم `char` هنا، لكن الرابعة والسادسة ليست أحرفاً: إنها علامات تشكيل لا معنى لها بمفردها. أخيراً، إذا نظرنا إليها كـ Grapheme Clusters، فسنحصل على ما يسميه الشخص الأحرف الأربعة التي تشكل الكلمة الهندية:

```text
["न", "م", "स्", "ته"]
```

توفر Rust طرقاً مختلفة لتفسير بيانات السلسلة الخام التي تخزنها الحواسيب بحيث يمكن لكل برنامج اختيار التفسير الذي يحتاجه، بغض النظر عن اللغة البشرية التي كتبت بها البيانات.

السبب الأخير الذي يجعل Rust لا تسمح لنا بالفهرسة في `String` للحصول على حرف هو أن عمليات الفهرسة يُتوقع منها دائماً أن تأخذ وقتاً ثابتاً (O(1)). ولكن ليس من الممكن ضمان هذا الأداء مع `String` لأن Rust ستضطر إلى المرور عبر المحتويات من البداية إلى الفهرس لتحديد عدد الأحرف الصالحة الموجودة.

### تشريح السلاسل النصية (Slicing Strings)

غالباً ما تكون الفهرسة في سلسلة نصية فكرة سيئة لأنه ليس من الواضح ما يجب أن يكون عليه النوع المرتجع لعملية فهرسة السلسلة: قيمة بايت، أو حرف، أو عنقود رموز، أو شريحة سلسلة نصية. إذا كنت بحاجة حقاً لاستخدام الفهارس لإنشاء String Slices، فإن Rust تطلب منك أن تكون أكثر تحديداً.

بدلاً من الفهرسة باستخدام `[]` مع رقم واحد، يمكنك استخدام `[]` مع نطاق (Range) لإنشاء String Slice يحتوي على بايتات معينة:

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

هنا، ستكون `s` عبارة عن `&str` تحتوي على أول 4 بايتات من السلسلة. ذكرنا سابقاً أن كل حرف من هذه الأحرف كان 2 بايت، مما يعني أن `s` ستكون `Зд`.

إذا حاولنا تشريح جزء فقط من بايتات حرف ما باستخدام شيء مثل `&hello[0..1]` فستقوم Rust بالهلع (Panic) في وقت التشغيل بنفس الطريقة التي يحدث بها الوصول إلى فهرس غير صالح في متجه:

```console
{{#include ../listings/ch08-common-collections/output-only-01-not-char-boundary/output.txt}}
```

يجب عليك توخي الحذر عند إنشاء String Slices باستخدام النطاقات، لأن القيام بذلك قد يؤدي إلى تعطل برنامجك.

<!-- Old headings. Do not remove or links may break. -->

<a id="methods-for-iterating-over-strings"></a>

### التكرار عبر السلاسل النصية (Iterating Over Strings)

أفضل طريقة للتعامل مع أجزاء من السلاسل النصية هي أن تكون صريحاً بشأن ما إذا كنت تريد أحرفاً أم بايتات. بالنسبة لـ Unicode Scalar Values الفردية، استخدم Method الـ `chars`. استدعاء `chars` على "Зд" يفصل ويعيد قيمتين من نوع `char` ويمكنك التكرار (Iterate) عبر النتيجة للوصول إلى كل عنصر:

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

سيطبع هذا الكود ما يلي:

```text
З
д
```

بدلاً من ذلك، تعيد Method الـ `bytes` كل بايت خام، وهو ما قد يكون مناسباً لمجالك:

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

سيطبع هذا الكود الـ 4 بايتات التي تشكل هذه السلسلة:

```text
208
151
208
180
```

لكن تأكد من تذكر أن Unicode Scalar Values الصالحة قد تتكون من أكثر من 1 بايت.

الحصول على Grapheme Clusters من السلاسل النصية، كما هو الحال مع خط الديفاناغاري، أمر معقد، لذا لا توفر المكتبة القياسية هذه الوظيفة. تتوفر حزم (Crates) على [crates.io](https://crates.io/) إذا كانت هذه هي الوظيفة التي تحتاجها.

<!-- Old headings. Do not remove or links may break. -->

<a id="strings-are-not-so-simple"></a>

### التعامل مع تعقيدات السلاسل النصية (Handling the Complexities of Strings)

باختصار، السلاسل النصية معقدة. تتخذ لغات البرمجة المختلفة خيارات مختلفة حول كيفية تقديم هذا التعقيد للمبرمج. اختارت Rust جعل التعامل الصحيح مع بيانات `String` هو السلوك الافتراضي لجميع برامج Rust، مما يعني أن المبرمجين يضطرون إلى التفكير أكثر في التعامل مع بيانات UTF-8 مسبقاً. تكشف هذه المقايضة عن المزيد من تعقيد السلاسل النصية عما هو ظاهر في لغات البرمجة الأخرى، ولكنها تمنعك من الاضطرار إلى التعامل مع الأخطاء التي تتضمن أحرفاً غير تابعة لـ ASCII لاحقاً في دورة حياة التطوير الخاصة بك.

الخبر السار هو أن الـ Standard Library تقدم الكثير من الوظائف المبنية على نوعي `String` و `&str` للمساعدة في التعامل مع هذه المواقف المعقدة بشكل صحيح. تأكد من مراجعة التوثيق للتعرف على Methods مفيدة مثل `contains` للبحث في سلسلة نصية و `replace` لاستبدال أجزاء من سلسلة نصية بسلسلة أخرى.

دعنا ننتقل إلى شيء أقل تعقيداً قليلاً: جداول التجزئة (Hash Maps)!
